<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习：Dynamic Programming</title>
      <link href="/2019/04/09/Programming/"/>
      <url>/2019/04/09/Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>动态规划（Dynamic Programming）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。——wikipedia</p></blockquote><p>最近陆续参加大厂的春招，发现许多大厂的笔试都会放出至少一道dp算法，可见dp算法在实际业务中的应用十分广泛。然后，我又不会做，所以还是写篇blog来记录一下学习过程。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>以下是非常经典的dp题目：</p><blockquote><p>小明有1元，3元，8元，18元，67元的某种货币硬币各若干枚，现在他需要出门购买一份价值277元的礼物，请问他最少需要带多少枚硬币？</p></blockquote><p><strong>约定：为方便，设f(x)=n；其中n为最后数量，x为价值。</strong></p><p>显然，我们的第一反应是从面值大的开始拿，先拿67的，拿不下了再换18的……以此类推，最后我们会拿 <code>67*4 + 8*1 + 1*1</code> 刚好拿完我们的277元，<code>f(277)=6</code>。显然这个结果来的太顺利了，如果我们现在的情况如下：</p><blockquote><p>小明有1元，18元，67元的某种货币硬币各若干枚，现在他需要出门购买一份价值80元的礼物，请问他最少需要带多少枚硬币？</p></blockquote><p>那完了，我们从大的开始拿需要 <code>67*1 + 1*13</code> ，此时<code>f(80)=14</code>，但是我们把各种情况代进去就会发现其实 <code>18*4 + 1*8</code> 这种情况下 <code>f(80)=12</code> 才是最优情况。事实上，在运用贪心算法解决问题的时候，我们必须首先证明该算法是最优算法（最安全）。 </p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><blockquote><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems. ——Wikipedia</p></blockquote><p>dp问题的本质在于去寻找各个子问题状态中的最优解，其中在大部分情况下，子问题可以理解为下一步（next step）。for一个sample：</p><p>我们面对这个80块，我们可以在下一步产生三种状态： <code>67*1 + 13</code> <code>18*1 + 62</code> 和 <code>1*1 + 79</code> ，这就是上一个问题的三个子问题。这个时候我们发现，我们不再需要关心上一个问题（如何凑80元）是怎么解决的了，现在我们知道，<code>f(80)</code> <code>f(13)+1</code> <code>f(62)+1</code> <code>f(79)+1</code>四个问题一定在最优解情况下相等，这就是dp问题的无后效性。</p><p>最后，在我们不断地“查询”子问题状态的时候，整个问题的选择将会变成一棵树，我们只需要查询树中从任一叶到根的最短路径的长度即可得出问题的解。</p><h2 id="状态储存"><a href="#状态储存" class="headerlink" title="状态储存"></a>状态储存</h2><p>给出一个再熟悉不过的计算n=5的斐波那契的代码(in Golang)</p><pre><code class="Golang">func Fib(n int) int {  if (n == 0){    return 0  }  if (n == 1){    return 1  }  return Fib(n-1) + Fib(n-2)}func main(){  Fib(5)}</code></pre><p>这也是一个很明显的子问题可以画成一棵树的问题，但实际问题在于： <code>Fib(5)</code> 花费掉我608ns， <code>Fib(40)</code>花费掉我1.063243715s，<code>Fib(45)</code>花费掉我11.183974111s。显然，根据树的数据结构，我们计算递归子问题的时间随着子问题深度的变大而变得十分庞大，当算法要求给出的总数达到一定数量级之后，我们便永远不可能通过不断地递归调用而寻找子问题中的最优解。</p><p><strong>我们的时间花费在了哪里呢？</strong></p><p>很显然，我们的时间花费在了大量重复的计算上，很容易就能想到，这棵树有多少叶子节点，我们便计算了多少次 <code>Fib(0)</code> 的结果，往上推，这一系列重复的动作是从某几根重复的树枝延伸出来的，这个时候，我们需要将已经计算过的结果储存起来。</p><p>在进行运算的过程中，我们注意到，整个斐波那契函数的形参是由大变小的。所以，如果我们想要在计算中使用已经储存的结果，那么我们需要有小到大计算斐波那契函数的结果。</p><pre><code class="Golang">var tmp []intfunc Fib(n int) int {  //有结果优先返回  if (len(tmp) &gt;= n){    return tmp[n]  }  if (n == 0){    tmp = append(tmp, 0)    return 0  }  if (n == 1){    tmp = append(tmp, 1)    return 1  }  rs := Fib(n-1) + Fib(n-2)  tmp = append(tmp, rs)  return rs}func main(){  Fib(45)}</code></pre><p>打扰了！上面代码的运行时间27.549µs，多次测试也稳定在30µs以内。差别巨大，至此为止，这个斐波那契函数我们基本可以认为是时间复杂度O(n)的算法。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>回来帮小明解决买东西的问题，我们仅仅需要将80元以下所有的情况都计算保存，并在计算下一个状态的时候考虑能否用大额硬币替换小额硬币，就能够把该问题通过一个时间复杂度O(n)的算法解决。</p><pre><code class="Golang">var tmp []intfunc GetNum(n int){  //给一个足够大的初始值，可以是最大值  num := 80  if (n-1 &gt;= 0){    if (tmp[n-1]+1 &lt; num){      num = tmp[n-1] + 1    }  }  if (n-18 &gt;= 0){    if (tmp[n-18]+1 &lt; num){      num = tmp[n-18] + 1    }  }  if (n-67 &gt;= 0){    if (tmp[n-67]+1 &lt; num){      num = tmp[n-67] + 1    }  }  //写入tmp  if (len(tmp) &lt;= n){    tmp = append(tmp, num)  }}func main(){  //压入初始值tmp[0]  tmp = append(tmp, 0)  var i int  //生成整个tmp  for i=1; i&lt;=80; i++ {    GetNum(i)  }  fmt.Println(tmp[80])}</code></pre><h2 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h2><p>实际题目中，会将总价x、货币数量以及面值，通过STDIN传入，并通过TestCase处理。下面是一般化题目：</p><pre><code>小明有N种不同面值的某种货币硬币各若干枚，现在他需要出门购买一份价值M元的礼物，请问他最少需要带多少枚硬币？题目输入的第一行给出两个数字分别为总价和货币面值的数量，从后一行开始，每一行为一个面值，请输出最少携带的硬币。用例：  输入：    80 3    1    18    67  输出：    12</code></pre><pre><code class="Golang">func GetNum(n int, price []int, tmp []int) []int{  num := 2^32  for i:=0; i&lt;len(price); i++{    if (n-price[i] &gt;= 0){      if (tmp[n-price[i]]+1 &lt; num){        num = tmp[n-price[i]] + 1      }    }  }  if (len(tmp) &lt;= n){    tmp = append(tmp, num)  }  return tmp}func main(){  //获取输入  var n,m int  var price []int  fmt.Scan(&amp;m)  fmt.Scan(&amp;n)  for i:=0; i&lt;n; i++ {    x := 0    fmt.Scan(&amp;x)    price = append(price, x)  }  sort.Ints(price)  var tmp []int  tmp = append(tmp, 0)  for j:=1; j&lt;=m; j++ {    tmp = GetNum(j, price, tmp)  }  fmt.Println(tmp[m])}</code></pre><p>呼~长舒一口气</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署相关</title>
      <link href="/2019/03/29/Docker%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/03/29/Docker%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是由Golang开发的轻量级虚拟容器技术，主要目的是解决在生产环境中的环境、依赖配置问题和单机多部署的性能提升问题。</p><h3 id="环境打包"><a href="#环境打包" class="headerlink" title="环境打包"></a>环境打包</h3><p>在docker环境构建时，我们通过以下命令构建新的容器</p><pre><code>docker run {imageName:Version/Tag} {command}</code></pre><p>我们可以通过docker打包解决环境差别问题，下面以php-fpm环境为例：<br><a href="http://www.runoob.com/docker/docker-install-php.html" target="_blank" rel="noopener">菜鸟教程</a></p><ul><li>选择目录并新建dockerfile<br><code>`</code><br>FROM ubuntu:16.01<br>MAINTAINER ERIEN <a href="mailto:97516719@QQ.COM" target="_blank" rel="noopener">97516719@QQ.COM</a></li></ul><p>ADD <a href="http://nginx.org/download/nginx-1.15.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.15.0.tar.gz</a><br>RUN tar zxf nginx-1.15.0.tar.gz<br>RUN mkdir /usr/local/nginx<br>COPY ./nginx-1.15.0 /usr/local/nginx<br><code>`</code> </p><p>这样子我们就完成了在一个docker文件中配置nginx，只要在docker中启动这个文件就可以完成构建。</p><h3 id="单机多部署"><a href="#单机多部署" class="headerlink" title="单机多部署"></a>单机多部署</h3><p>很容易可以想到，在同一台主机上通过docker可以简单部署多个相同的服务来模拟分布式，发挥一台主机的性能优势。在以前，会采用虚拟机的方式去进行部署。<br>虚拟机和docker差别如下<br><img src="https://img-blog.csdn.net/20180711090727241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aHVuYmlhbmNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="性能差别"><br>很容易看出来，docker绕过了系统层面的交互，使得每个容器能够直接地和docker引擎（类似中间件）进行通信，从而避免了多次请求底层系统的内存开销。<br>在性能方面，docker的启动时间简直令人发指，一个基本的LNMP的docker服务的启动仅仅需要7秒左右，但如果这个效果放在虚拟机中，可能会翻好几倍。<br>在储存方面，docker在大部分的语言、数据库镜像的处理上，实现了简易版的体积，例如在数据库方面，数据储存的切片并不会直接储存在docker的“包”里，而是由docker层面提供一个直接和系统交互的切片空间储存，所以尽管在大型服务上线很久之后，我们查看docker的体积也仅仅占几十M左右。</p><p>（待更新）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1&amp;HTTP2</title>
      <link href="/2019/03/26/HTTP1-HTTP2/"/>
      <url>/2019/03/26/HTTP1-HTTP2/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP1"><a href="#HTTP1" class="headerlink" title="HTTP1"></a>HTTP1</h3><p>HTTP（Hypertext Transfer Protocol）超文本传输协议<br>它是用来在Internet上传送超文本的传送协议。它是运行在TCP/IP协议簇之上的HTTP应用协议，它可以使浏览器更加高效，使网络传输减少。任何服务器除了包括HTML文件以外，还有一个HTTP驻留程序，用于响应用用户请求。您的浏览器是HTTP客户，向服务器发送请求，当浏览器中输入了一个开始文件或点击了一个超级链接时，浏览器就向服务器发送了HTTP请求，此请求被送往由URL指定的IP地址。驻留程序接收到请求，在进行必要的操作后回送所要求的文件。</p><p>在HTTP1.0版本中，前端需要在向后端发起请求的时候添加<code>keep-alive</code>头部来知会后端此次数据传输需要开启长连接，但是因为数据传输的不同，并非所有的传输都要建立长连接，所以对每次请求都发起一个新的请求显然是一种浪费的表现。<br>在HTTP1.1中，HTTP协议默认支持长连接，但是默认的支持长连接可能会造成带宽/服务器资源的浪费。所以在HTTP1.1中，header信息和body信息并非同步被发送到服务器，HTTP1.1会先接受header信息并处理返回，前端再根据返回的结果决定是否继续传输数据（1xx同意/4xx拒绝）。</p><p>同时，在早起的HTTP1.0协议中，协议并不认为同一服务器上包含一个以上的ip地址，显然在现在有虚拟机分割的情况下，HTTP1.1协议加入和Host头部，为所有的request和response信息提供一个地址。</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP/2 （原名HTTP/2.0）即超文本传输协议 2.0，是下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新。HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP 2.0将只用于https://网址，而 http://网址将继续使用HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。</p><h4 id="HTTP2主要新内容"><a href="#HTTP2主要新内容" class="headerlink" title="HTTP2主要新内容"></a>HTTP2主要新内容</h4><ul><li>多路复用</li><li>头部压缩</li><li>流式数据</li><li>二进制数据形式</li><li>服务端推送</li></ul><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>在HTTP1.x中，浏览器对后端发起的请求一般采用管道（HTTP2使用的是二进制传送，二进制传送的单位是帧和流），可以理解为队列，</p><h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h5><p>随着页面的发展，会有越来越多的静态资源会随着网页页面的加载而被请求，如图片、css、字体等等，但是其实我们每一次请求这一类资源都是使用（基本）相同的请求头部，甚至是多余的（比如重复的cookie，timestamp等等），这个时候，header压缩就显得十分之有必要了。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。（p.s. HTTP2的头部压缩使用<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">HPACK算法</a>）</p><h5 id="流式数据"><a href="#流式数据" class="headerlink" title="流式数据"></a>流式数据</h5><p>HTTP2使用的是二进制传送，二进制传送的单位是帧和流，不需要像HTTP1一样按包为传输单位，这再次提高了长连接的效率</p><h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>在tcp/ip连接建立之后，服务端可以在未经请求的情况下，自行向客户端推送内容。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php中的gc</title>
      <link href="/2019/03/22/php%E4%B8%AD%E7%9A%84gc/"/>
      <url>/2019/03/22/php%E4%B8%AD%E7%9A%84gc/</url>
      
        <content type="html"><![CDATA[<p>##php中的垃圾回收</p><p>###前言：引用计数<br>PHP中每一个变量的定义都会定义在在一个容器中，容器中提供两个额外的属性，<code>is_ref</code>和 <code>refcount</code>。分别代表该变量是否为引用变量，以及该变量被引用的次数；易知，<code>refcount</code>为1的时候<code>is_ref</code>为false，此时全局没有对该对象的引用，只有本身定义。</p><p><br><br>在<a href="http://php.net/manual/zh/features.gc.refcounting-basics.php#features.gc.compound-types" target="_blank" rel="noopener">复合类型(Compound Types)</a> 如<code>Array</code>、<code>Object</code>的定义中，以键值对的形式包含多个基本类型定义的容器</p><p>以下例子来自手册：</p><pre><code class="php">&lt;?php$a = array( &#39;meaning&#39; =&gt; &#39;life&#39;, &#39;number&#39; =&gt; 42 );xdebug_debug_zval( &#39;a&#39; );?&gt;//内部定义形式a: (refcount=1, is_ref=0)=array (   &#39;meaning&#39; =&gt; (refcount=1, is_ref=0)=&#39;life&#39;,   &#39;number&#39; =&gt; (refcount=1, is_ref=0)=42)</code></pre><p>###<code>isset</code>和<code>unset</code>函数<br><code>isset()</code>函数用于检测某个变量是否被定义（是否存在变量的地址），<code>isset()</code>函数会通过检测容器的<code>refcount</code>参数去检测函数的定义。<br><br><br><code>unset()</code>用于释放一个变量，类似c语言中的<code>free()</code>，但是也不同，当函数对某个变量调用的时候，不会直接释放该内存，而是将该变量容器中的<code>refcount</code>属性减一。</p><p>###垃圾回收与变量生命周期<br>在旧版的php中（&lt;=5.3），不存在主动探测的可能为垃圾变量的动作，只有当变量中的<code>refcount</code>减少的时候，才会产生垃圾周期并检测变量的引用数是否为零，从而发现垃圾。<br><br><br>但是这种方法在每一个变量的每一次引用减少时都会被全局调用，在性能上有极大的浪费，所以在新版本（php&gt;=5.4）中，引入新的检测算法来执行垃圾回收。<br><br><br>在新的算法中，引入了变量数的阈值，这个值在编译好的php中是10000，为变量缓冲区的大小。当到达这个阈值的时候，将开始执行以下程序：</p><ul><li>首先，所有可能根变量都放在一个根缓冲区，并标记为可疑垃圾；</li><li>然后，模拟删除每一个可疑变量（将引用次数减一）并确保每个变量会且只会被执行一次该操作；</li><li>其次，模拟恢复每一个引用计数大于零的变量（该操作也会对同一变量执行一次）；</li><li>最后，真正删除没能恢复的变量，这些变量就为垃圾。</li></ul><p><a href="http://php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">PHP手册-垃圾回收机制</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang中go关键字和channel的使用</title>
      <link href="/2018/09/17/Golang%E4%B8%ADgo%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cchannel%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/17/Golang%E4%B8%ADgo%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cchannel%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>###Golang中的 <code>go</code> 关键字</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js异步调用和阻止</title>
      <link href="/2018/07/26/js%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%92%8C%E9%98%BB%E6%AD%A2/"/>
      <url>/2018/07/26/js%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%92%8C%E9%98%BB%E6%AD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="js的异步调用精髓和阻止方法"><a href="#js的异步调用精髓和阻止方法" class="headerlink" title="js的异步调用精髓和阻止方法"></a>js的异步调用精髓和阻止方法</h1><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><blockquote><p>JavaScript引擎是单线程运行的,浏览器无论在什么时候都只且只有一个线程在运行JavaScript程序。<br>JavaScript引擎用单线程运行也是有意义的,单线程不必理会线程同步这些复杂的问题,问题得到简化。</p></blockquote><p>为了弥补js单线程机制，引入异步调用机制<br><img src="http://images2015.cnblogs.com/blog/638135/201607/638135-20160721111145247-341211472.png" alt="js流程"></p><p>在event loop中存在一个类似带有出口的死循环机制，在完成function主体部分后开始被调用。</p><pre><code class="JavaScript">XXX: function(){  //do sth...  Success: function() {    /*    callback body      do sth before      Add sth to TODO    */  }}</code></pre><p>异步操作会检测回调任务队列总中的任务，完成后将之后新的检测添加到个循环中<br><br>由于callback结束时间无法准确给出，所以js中程序调用的先后级只规定在function主体中。</p><blockquote><p>优点：将剩下待处理的交给callback，延后function结束时间，类似创建监视器。<br>缺点：下一个function运行所需的数据仍在回调加载中，会给出错误。</p></blockquote><p><a href="https://blog.csdn.net/qdq2014/article/details/72383725/" target="_blank" rel="noopener">js异步机制</a></p><h2 id="回调阻止"><a href="#回调阻止" class="headerlink" title="回调阻止"></a>回调阻止</h2><p>对于上面的缺点，一般有两种方法规避。</p><blockquote><p>将下一个进行的function写入上一个function的callback中<br>引入Promise对象</p></blockquote><p>主要讲Promise对象 <code>Promise.all</code><br></p><p>Promise规范如下：</p><blockquote><p>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）<br>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换<br>promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致。<br>then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。</p></blockquote><pre><code class="JavaScript">function getImg(url) {    var p = Promise();    var img = new Image();    //当img生成时会触发onload函数，在onload函数中将Promise对象的状态设为完成  img.onload = function() {      p.resolve(this);    };  //出错时设为拒绝调用下一步  img.onerror = function(err) {      p.reject(err);    };    img.url = url;  //返回整体程序的完成程度    return p;  };  </code></pre><p>以上代码可以写为</p><pre><code>function getImg(url) {    return Promise(function(resolve, reject) {      var img = new Image();      img.onload = function() {        resolve(this);      };      img.onerror = function(err) {        reject(err);      };      img.url = url;    });  };</code></pre><p>总体：通过Promise状态决定下一步调用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新centOS主机配置mysql和nginx</title>
      <link href="/2018/07/25/%E6%96%B0centOS%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AEmysql%E5%92%8Cnginx/"/>
      <url>/2018/07/25/%E6%96%B0centOS%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AEmysql%E5%92%8Cnginx/</url>
      
        <content type="html"><![CDATA[<h1 id="新centOS主机配置mysql和nginx"><a href="#新centOS主机配置mysql和nginx" class="headerlink" title="新centOS主机配置mysql和nginx"></a>新centOS主机配置mysql和nginx</h1><hr><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><em>mysql</em></h2><pre><code>//获取版本安装repo 这里安装mysql57[user]# wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm[user]# rpm -ivh mysql57-community-release-el7-8.noarch.rpm//安装后续服务端 用yum神器[user]# yum install mysql-server//一路 yes到complete为止//启动 mysql获取密码[user]# service mysqld start[user]# grep &quot;password&quot; /var/log/mysqld.log//改密码开放远程权限[user]# mysql -u root -pmysql&gt; alter user user() indentified by &#39;NEW PASSWORD&#39;;mysql&gt; update mysql.user host = &#39;%&#39; where user = &#39;root&#39;;</code></pre><hr><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><em>Nginx</em></h2><pre><code>//要求sudo安装 yes到底[user]# sudo yum install nginx//启动[user]# sudo systemctl nginx</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php+nginx配置laravel</title>
      <link href="/2018/07/25/php+nginx%E9%85%8D%E7%BD%AElaravel/"/>
      <url>/2018/07/25/php+nginx%E9%85%8D%E7%BD%AElaravel/</url>
      
        <content type="html"><![CDATA[<p>Laravel框架入口函数在 <code>/public/index.php</code><br><br>通过设置nginx.conf将root入口设置为<code>/public</code> 即可</p><pre><code class="nginx.conf">server {    listen 80;    server_name example.com;    root /example.com/public;    add_header X-Frame-Options &quot;SAMEORIGIN&quot;;    add_header X-XSS-Protection &quot;1; mode=block&quot;;    add_header X-Content-Type-Options &quot;nosniff&quot;;    index index.html index.htm index.php;    charset utf-8;    location / {        try_files $uri $uri/ /index.php?$query_string;    }    location = /favicon.ico { access_log off; log_not_found off; }    location = /robots.txt  { access_log off; log_not_found off; }    error_page 404 /index.php;    location ~ \.php$ {        fastcgi_split_path_info ^(.+\.php)(/.+)$;        fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;        fastcgi_index index.php;        include fastcgi_params;    }    location ~ /\.(?!well-known).* {        deny all;    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go中cookie维持</title>
      <link href="/2018/07/25/go%E4%B8%ADcookie%E7%BB%B4%E6%8C%81/"/>
      <url>/2018/07/25/go%E4%B8%ADcookie%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>使用cookieJa对response中的cookie进行存储</p><pre><code class="go">import &quot;net/http/cookiejar&quot;func main() {    var client http.Client    jar, err := cookiejar.New(nil)    if err != nil {        panic(err)    }    client.Jar = jar    client.Post(...) // 在这里登陆    client.Get()     // 后续请求client会自动将cookie加入}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高版本macOS中安装软件权限注意事项</title>
      <link href="/2018/07/25/%E9%AB%98%E7%89%88%E6%9C%ACmacOS%E4%B8%AD%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%9D%83%E9%99%90%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2018/07/25/%E9%AB%98%E7%89%88%E6%9C%ACmacOS%E4%B8%AD%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%9D%83%E9%99%90%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>#奇妙旅程</p><hr><p>###mysql莫名其妙写入失败！<br>删除后brew不能使用需要brew update<br><br>update需要 chmod /usr/local<br><br>高版本的根本不允许好吗！<br><br>sudo都能 operation not permitted！<br></p><hr><p>###原因</p><p><a href="https://blog.csdn.net/yemao_guyue/article/details/80575532" target="_blank" rel="noopener">MAC /usr/bin/目录下 Operation not permitted的解决</a><br><br>真凶的解决办法和原理<br><br>但是破坏原有机制不是好办法</p><hr><p>###解决方法<br>跳过这个步骤 卸载brew后重装<br><br><a href="https://blog.csdn.net/yemao_guyue/article/details/80575532" target="_blank" rel="noopener">chown: /usr/local: Operation not permitted问题解决</a><br><br>纯属记录</p><hr><p>###新状况<br>虚拟环境识别不出_mysql包<br><br>原因大概是mysql8有点新不支持 找不到解析包<code>libmysqlclient.20.dylib</code><br><br>其实 <code>/usr/local/Cellar/mysql/8.0.11/lib</code> 下有一个文件叫 <code>libmysqlclient.21.dylib</code><br><br>目前找不到别的方法，名字强行改一下竟然 好了。。。。。<br><br>终结</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2018/07/25/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/25/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-搭建个人博客"><a href="#Django-搭建个人博客" class="headerlink" title="Django 搭建个人博客"></a>Django 搭建个人博客</h1><hr><p>第一次使用Django搭建网页，和PHP有相似的地方，后端渲染（数据绑定）返回前端页面。但是相比较于PHP，django有更为明显和直接的优点：</p><blockquote><ul><li>强大的模板渲染</li><li>自身的数据库模型</li><li>代码整体迁移能力整体</li><li>更大型的网站架构和插件</li></ul></blockquote><p>环境：macos + python3.6 + django2.0 + pycharm2018.2<br><br>使用Pycharm进行Django项目的初始化，免除了</p><pre><code class="python">$ sudo python3 django-admin.py startproject blog</code></pre><p>这样一个过程</p><hr><p>首先新建我们所需要用到的文章应用（app）</p><pre><code class="python">$ sudo python3 manage.py startapp article</code></pre><p>在setting文件中添加article应用，并设置好一篇文章的数据库储存方式。这里我采用的是</p><pre><code class="python">class Article(models.Model):    title = models.CharField(u&#39;标题&#39;, max_length=50)    id = models.AutoField(primary_key=True)    pub_date = models.DateTimeField(u&#39;发布日期&#39;,auto_now_add=True, editable=False)    edit_date = models.DateTimeField(u&#39;最后修改日期&#39;, auto_now=True, editable=False)    content = models.TextField(blank=True, null=True)</code></pre><p>这样的一个数据格式，通过主键ID拿到文章数据。<br><br><br><br>首先设置root账户以及绑定后台对Article模型的管理</p><pre><code class="python">$ sudo python3 manage.py createsuperuser</code></pre><p>并完成后续，同时注册模型</p><pre><code class="python">#/article/admin.pyfrom django.contrib import adminfrom .models import Articleadmin.site.register(Article)</code></pre><p>django为我们提供了一个很好的后台管理系统，这里我用来做文章的发布和修改。<br></p><hr><p>整个博客有两个页面<code>index</code>和<code>article</code>分别是主页和文章的详细内容。<br><br>主页通过</p><pre><code class="python">def index(request):    Article_list = Article.objects.order_by(&#39;-pub_date&#39;)    template = loader.get_template(&#39;index/index.html&#39;)    context = {        &#39;list&#39;: Article_list,    }    return HttpResponse(template.render(context, request))</code></pre><p>拉取文章列表并通过</p><pre><code class="python">{% for article in list %}    #do sth..{% endfor %}</code></pre><p>进行读取。<br><br><br>在article页面通过传入的参数</p><pre><code class="python">def article(request, id_):    article_ = get_object_or_404(Article, id=id_)    article_.content = markdown.markdown(article_.content,extensions=[&#39;markdown.extensions.extra&#39;,&#39;markdown.extensions.codehilite&#39;,&#39;markdown.extensions.toc&#39;,])template = loader.get_template(&#39;article/article.html&#39;)    context = {        &#39;article&#39;: article_,    }    return HttpResponse(template.render(context,request))</code></pre><p>拿到文章内容或抛出404<br>这里可以看到，我在文章详情页模板中使用了Markdown语法，是通过python中的 <a href="https://github.com/Python-Markdown/markdown" target="_blank" rel="noopener">Markdown</a> 解析库实现的。<br><br>在数据库中存放的是带有Markdown语法的文本，通过Markdown解析成为html语言后插入。<br><br>这里有两点需要注意的：</p><blockquote><ul><li>django对html文本加载的阻止</li><li>html标签的样式</li></ul></blockquote><p>一般的框架都有防止xss注入的过程，关闭django的阻止可以让html代码成功加载</p><pre><code class="python">{% autoescape off %}    {{ article.content }}{% endautoescape %}</code></pre><p>然后，Markdown解析库并不会在生成html代码的时候给出css样式，所以 <code>⌘ + Alt + I</code> 打开Chrome的开发者工具对照每个html的类名将你喜欢的css样式写进相应的css文件中</p><hr><p>写markdown语法要有很好的对照，推荐 <a href="https://www.zybuluo.com/" target="_blank" rel="noopener">Cmd Markdown编辑阅读器</a> 除了注册才能保存其他我觉得都很好。<br><br><br><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"><br><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager">有很好的编辑栏<br></p><hr><p>万事预备只欠东风，准备一下就可以放到服务器上</p><blockquote><ul><li>制作数据库迁移文件</li><li>关闭DEBUG模式</li><li>修改可访问域名</li></ul></blockquote><p>制作迁移文件</p><pre><code class="python">$ sudo python3 manage.py makemigrations</code></pre><p>然后在setting文件中DEBUG改为False<br><br>下面allowed_host改为[‘*’]任意域名模式<br><br><br>移动到服务器后进行数据库合并</p><pre><code class="python">$ sudo python manage.py migrate</code></pre><p>最后由于关闭了debug模式，常规下是无法读取静态文件的，开启端口监听的时候选择不安全模式。</p><pre><code class="python">$ sudo python manage.py runserver 0.0.0.0:80 --insecure</code></pre><p>就可以啦！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建php+apache细节</title>
      <link href="/2018/07/25/Ubuntu%E6%90%AD%E5%BB%BAphp+apache%E7%BB%86%E8%8A%82/"/>
      <url>/2018/07/25/Ubuntu%E6%90%AD%E5%BB%BAphp+apache%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>#Ubuntu搭建php+apache细节</p><p>Ubuntu搭建微博框架<a href="http://120.78.190.79/main.php" target="_blank" rel="noopener">EMicroblog</a>，其中在Linux下搭建php和apache需要注意一些事情，本文以Ubuntu为例。<br><br><br><a href="mailto:&#x39;&#55;&#53;&#49;&#x36;&#x37;&#x31;&#x39;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x39;&#55;&#53;&#49;&#x36;&#x37;&#x31;&#x39;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a></p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h4 id="Mysql-Apache-PHP"><a href="#Mysql-Apache-PHP" class="headerlink" title="Mysql Apache PHP"></a>Mysql Apache PHP</h4><pre><code class="bash">$ sudo apt-get install mysql-server mysql-client$ sudo apt-get install apache2$ sudo apt-get install php7.0</code></pre><p>以上安装过程中会有相应提示，其中mysql安装会提示设置root账户密码</p><h4 id="安装apache-php-module"><a href="#安装apache-php-module" class="headerlink" title="安装apache php module"></a>安装apache php module</h4><pre><code class="bash">$ sudo apt-get install libapache2-mod-php7.0</code></pre><h4 id="重启apache"><a href="#重启apache" class="headerlink" title="重启apache"></a>重启apache</h4><pre><code>$ sudo /etc/init.d/apache2 restart</code></pre><p>通过浏览器访问 <b><code>http://localhost</code></b>来查看apache是否有用。</p><p></p><p style="color: #2aa198"><del>至此环境已经部署完毕</del></p> 有兴趣的还可以继续安装phpMyAdmin<p></p><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><p>Linux内核中十分注重权限分配，对于有文件/文件夹读写需求的apache服务组<code>www-data</code>，我们需要分配文件夹权限。</p><pre><code>$ cd /var/www$ sudo chmod 777 html</code></pre><p>其中<code>/html</code>为apache初始项目组。如果项目文件夹下有多层目录，将上述第二行命令递归调用</p><pre><code>$ sudo chmod -R 777 html</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
